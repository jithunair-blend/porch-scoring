# This workflow will build and push a new container image to Amazon ECR,
# and then will launch a one-time ECS Fargate task (not a long-running service)
# whenever a push is made to the "main" branch.
#
# To use this workflow, please complete the setup steps below:
#
# 1. Create an ECR repository to store your images.
#    Example:
#      aws ecr create-repository --repository-name porch-scoring --region us-east-1
#
# 2. Create an ECS cluster and a task definition for your model scoring job.
#    You do NOT need an ECS Service for this workflow â€” the job will run once per trigger.
#    Example:
#      Cluster: porch-cluster
#      Task definition: porch-scoring-task
#
# 3. Store your ECS task definition JSON in your repository.
#    Example path: ci-cd-infra/task-definition.json
#    This file should match the output from:
#      aws ecs register-task-definition --generate-cli-skeleton
#
# 4. Store your AWS credentials in GitHub Actions secrets:
#    AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY
#
# 5. Update the subnet IDs and security group ID below
#    (taken from your ECS task and VPC setup).
#    These tell AWS which network configuration to use when launching Fargate.

name: Run one-time ECS Scoring Job

on:
  push:
    branches: [ "main" ]

env:
  # ---- AWS and ECS configuration ----
  AWS_REGION: us-east-1                   # AWS region for ECS and ECR
  ECR_REPOSITORY: porch-scoring           # Name of your Amazon ECR repository
  ECS_CLUSTER: porch-cluster              # Name of your ECS cluster
  ECS_TASK_DEFINITION: ci-cd-infra/task-definition.json  # Path to your ECS task definition JSON
  ECS_TASK_FAMILY: porch-scoring-task     #Adding Task Family
  CONTAINER_NAME: porch-scoring-container # Name of container in the task definition

  # ---- Networking (Fargate launch configuration) ----
  SUBNETS: subnet-0ea6ac99210fa56f4,subnet-079da42ab19f8fa27,subnet-0224e70262bf44635,subnet-0814469f85d83560a  # Replace/add subnets in your VPC
  SECURITY_GROUP: sg-084047e3ace01486         # Security group for Porch Automation

permissions:
  contents: read

jobs:
  deploy:
    name: Build and Run Scoring Task
    runs-on: ubuntu-latest
    environment: production

    steps:
    # ---------------------------------------------------------
    # Step 1: Checkout repository
    # ---------------------------------------------------------
    - name: Checkout
      uses: actions/checkout@v4

    # ---------------------------------------------------------
    # Step 2: Configure AWS credentials
    # ---------------------------------------------------------
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # ---------------------------------------------------------
    # Step 3: Login to Amazon ECR
    # ---------------------------------------------------------
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    # ---------------------------------------------------------
    # Step 4: Build, tag, and push Docker image to ECR
    # ---------------------------------------------------------
    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "Building and pushing Docker image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    # ---------------------------------------------------------
    # Step 5: Update ECS task definition with new image tag
    # ---------------------------------------------------------
    - name: Render new ECS task definition
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: ${{ env.ECS_TASK_DEFINITION }}
        container-name: ${{ env.CONTAINER_NAME }}
        image: ${{ steps.build-image.outputs.image }}

    # ---------------------------------------------------------
    # Step 6: Run ECS task once (not as a service)
    # ---------------------------------------------------------
    - name: Run ECS scoring task (one-time)
      id: run-task
      run: |
        echo "Launching ECS Fargate scoring task..."
        TASK_ARN=$(aws ecs run-task \
          --cluster ${{ env.ECS_CLUSTER }} \
          --launch-type FARGATE \
          --task-definition ${{ env.ECS_TASK_FAMILY }} \
          --network-configuration "awsvpcConfiguration={subnets=[${{ env.SUBNETS }}],securityGroups=[${{ env.SECURITY_GROUP }}],assignPublicIp=ENABLED}" \
          --count 1 \
          --query "tasks[0].taskArn" \
          --output text)
        echo "Task started: $TASK_ARN"
        echo "task_arn=$TASK_ARN" >> $GITHUB_OUTPUT

    # ---------------------------------------------------------
    # Step 7: Wait until task finishes (optional but recommended)
    # ---------------------------------------------------------
    - name: Wait for ECS task to complete
      run: |
        echo "Waiting for ECS task to complete..."
        aws ecs wait tasks-stopped \
          --cluster ${{ env.ECS_CLUSTER }} \
          --tasks ${{ steps.run-task.outputs.task_arn }}
        echo "ECS task completed successfully."

    # ---------------------------------------------------------
    # Step 8: Fetch CloudWatch logs (for visibility)
    # ---------------------------------------------------------
    - name: Fetch ECS task logs
      run: |
        LOG_GROUP="/ecs/${{ env.CONTAINER_NAME }}"
        echo "Fetching latest logs from CloudWatch group: $LOG_GROUP"
        aws logs get-log-events \
          --log-group-name $LOG_GROUP \
          --log-stream-name $(aws logs describe-log-streams \
            --log-group-name $LOG_GROUP \
            --order-by LastEventTime \
            --descending \
            --max-items 1 \
            --query "logStreams[0].logStreamName" \
            --output text) \
          --limit 50 \
          --output text || echo "No logs found."
