# This workflow will build and push a new container image to Amazon ECR,
# and then will launch a one-time ECS Fargate task (not a long-running service)
# whenever a push is made to the "main" branch.
#
# To use this workflow, please complete the setup steps below:
#
# 1. Create an ECR repository to store your images.
#    Example:
#      aws ecr create-repository --repository-name porch-scoring --region us-east-1
#
# 2. Create an ECS cluster and a task definition for your model scoring job.
#    You do NOT need an ECS Service for this workflow â€” the job will run once per trigger.
#    Example:
#      Cluster: porch-cluster
#      Task definition: porch-scoring-task
#
# 3. Store your ECS task definition JSON in your repository.
#    Example path: ci-cd-infra/task-definition.json
#    This file should match the output from:
#      aws ecs register-task-definition --generate-cli-skeleton
#
# 4. Store your AWS credentials in GitHub Actions secrets:
#    AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY
#
# 5. Update the subnet IDs and security group ID below
#    (taken from your ECS task and VPC setup).
#    These tell AWS which network configuration to use when launching Fargate.

name: Run one-time ECS Scoring Job

on:
  push:
    branches: [ "main" ]

env:
  # ---- AWS and ECS configuration ----
  AWS_REGION: us-east-1                   # AWS region for ECS and ECR
  ECR_REPOSITORY: porch-scoring           # Name of your Amazon ECR repository
  ECS_CLUSTER: porch-cluster              # Name of your ECS cluster
  ECS_TASK_DEFINITION: ci-cd-infra/task-definition.json  # Path to your ECS task definition JSON
  ECS_TASK_FAMILY: porch-scoring-task     # Task definition family name
  CONTAINER_NAME: porch-scoring-container # Name of container in the task definition

  # ---- Networking (Fargate launch configuration) ----
  SUBNETS: subnet-0ea6ac99210fa56f4,subnet-079da42ab19f8fa27,subnet-0224e70262bf44635,subnet-0814469f85d83560a  # Subnets from your VPC
  SECURITY_GROUP: sg-084047e530eae1486   # Security group for Porch Automation

permissions:
  contents: read

jobs:
  deploy:
    name: Build and Run Scoring Task
    runs-on: ubuntu-latest
    environment: production

    steps:
    # ---------------------------------------------------------
    # Step 1: Checkout repository
    # ---------------------------------------------------------
    - name: Checkout
      uses: actions/checkout@v4

    # ---------------------------------------------------------
    # Step 2: Configure AWS credentials
    # ---------------------------------------------------------
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    # ---------------------------------------------------------
    # Step 3: Login to Amazon ECR
    # ---------------------------------------------------------
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    # ---------------------------------------------------------
    # Step 4: Build, tag, and push Docker image to ECR
    # ---------------------------------------------------------
    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "Building and pushing Docker image..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    # ---------------------------------------------------------
    # Step 5: Render and register new ECS task definition
    # ---------------------------------------------------------
    - name: Fill in the new image ID in the Amazon ECS task definition
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: ${{ env.ECS_TASK_DEFINITION }}
        container-name: ${{ env.CONTAINER_NAME }}
        image: ${{ steps.build-image.outputs.image }}

    - name: Register updated ECS task definition
      id: register-task
      run: |
        echo "Registering new ECS task definition..."
        NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
          --cli-input-json file://${{ steps.task-def.outputs.task-definition }} \
          --query "taskDefinition.taskDefinitionArn" \
          --output text)
        echo "New task definition ARN: $NEW_TASK_DEF_ARN"
        echo "new_task_def_arn=$NEW_TASK_DEF_ARN" >> $GITHUB_OUTPUT

    # ---------------------------------------------------------
    # Step 6: Run ECS task once (not as a service)
    # ---------------------------------------------------------
    - name: Run ECS scoring task (one-time)
      id: run-task
      run: |
        echo "Launching ECS Fargate scoring task..."
        TASK_ARN=$(aws ecs run-task \
          --cluster ${{ env.ECS_CLUSTER }} \
          --launch-type FARGATE \
          --task-definition ${{ steps.register-task.outputs.new_task_def_arn }} \
          --network-configuration "awsvpcConfiguration={subnets=[${{ env.SUBNETS }}],securityGroups=[${{ env.SECURITY_GROUP }}],assignPublicIp=ENABLED}" \
          --count 1 \
          --query "tasks[0].taskArn" \
          --output text)
        echo "Task started: $TASK_ARN"
        # Persist for later steps
        echo "TASK_ARN=$TASK_ARN" >> $GITHUB_ENV
        # Derive the short Task ID (last path element of ARN)
        TASK_ID=${TASK_ARN##*/}
        echo "TASK_ID=$TASK_ID" >> $GITHUB_ENV

    # ---------------------------------------------------------
    # Step 7: Wait until task finishes (extended timeout)
    # ---------------------------------------------------------
    - name: Wait for ECS task to complete
      timeout-minutes: 60
      run: |
        echo "Waiting (up to 60 min) for ECS task to complete..."
        aws ecs wait tasks-stopped \
          --cluster ${{ env.ECS_CLUSTER }} \
          --tasks $TASK_ARN \
          --max-attempts 240
        echo "ECS task reached STOPPED."

    # ---------------------------------------------------------
    # Step 8: Check task exit code and stopped reason
    # ---------------------------------------------------------
    - name: Validate ECS task result
      run: |
        EXIT_CODE=$(aws ecs describe-tasks \
          --cluster ${{ env.ECS_CLUSTER }} \
          --tasks $TASK_ARN \
          --query "tasks[0].containers[?name=='${{ env.CONTAINER_NAME }}'].exitCode | [0]" \
          --output text)
        STOPPED_REASON=$(aws ecs describe-tasks \
          --cluster ${{ env.ECS_CLUSTER }} \
          --tasks $TASK_ARN \
          --query "tasks[0].stoppedReason" \
          --output text)
        echo "Container exit code: $EXIT_CODE"
        echo "Stopped reason: $STOPPED_REASON"
        if [ "$EXIT_CODE" != "0" ]; then
          echo "::error::ECS task failed with exit code $EXIT_CODE - $STOPPED_REASON"
          exit 1
        fi
        echo "ECS task completed successfully."

    # ---------------------------------------------------------
    # Step 9: Fetch CloudWatch logs (task-specific stream)
    # ---------------------------------------------------------
    - name: Fetch ECS task logs
      run: |
        LOG_GROUP="/ecs/porch-scoring"
        LOG_STREAM="ecs/${{ env.CONTAINER_NAME }}/$TASK_ID"
        echo "Fetching logs from $LOG_GROUP :: $LOG_STREAM"
        aws logs get-log-events \
          --log-group-name "$LOG_GROUP" \
          --log-stream-name "$LOG_STREAM" \
          --limit 200 \
          --output text || echo "No logs found for stream $LOG_STREAM."
